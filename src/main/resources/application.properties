# ======== Spring Boot Configuration ========
spring.application.name=persona-feedback-engine
spring.profiles.active=dev

# ======== Server Configuration ========
server.port=8080
server.servlet.context-path=/
server.error.include-message=always
server.error.include-stacktrace=on-param

# ======== Database Configuration ========
spring.jpa.database=POSTGRESQL
spring.datasource.url=jdbc:postgresql://postgres:5432/persona_feedback_db
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:postgres}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:postgres123456}
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true

# ======== Flyway Database Migration ========
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true

# ======== RabbitMQ Configuration ========
spring.rabbitmq.host=${SPRING_RABBITMQ_HOST:rabbitmq}
spring.rabbitmq.port=${SPRING_RABBITMQ_PORT:5672}
spring.rabbitmq.username=${SPRING_RABBITMQ_USERNAME:guest}
spring.rabbitmq.password=${SPRING_RABBITMQ_PASSWORD:guest}
spring.rabbitmq.virtual-host=${SPRING_RABBITMQ_VIRTUAL_HOST:/}
spring.rabbitmq.listener.simple.prefetch=1
spring.rabbitmq.listener.simple.acknowledge-mode=manual

# ======== Redis Configuration ========
spring.data.redis.host=${SPRING_REDIS_HOST:redis}
spring.data.redis.port=${SPRING_REDIS_PORT:6379}
spring.data.redis.password=${SPRING_REDIS_PASSWORD:redis123456}
spring.data.redis.timeout=${SPRING_REDIS_TIMEOUT:2000ms}
spring.data.redis.jedis.pool.max-active=20
spring.data.redis.jedis.pool.max-idle=10

# ======== Logging Configuration ========
logging.level.root=INFO
logging.level.ru.tigran.personafeedbackengine=DEBUG
logging.level.org.springframework.security=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n

# ======== Jackson Configuration (JSON) ========
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.serialization.indent-output=false
spring.jackson.default-property-inclusion=non_null

# ======== Spring Data REST Configuration ========
spring.data.rest.base-path=/api/v1

# ======== Actuator / Health Check ========
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=always
management.metrics.enable.all=true

# ======== Security Configuration ========
# CORS allowed origins for frontend integration
cors.allowed-origins=http://localhost:3000,http://localhost:8080,http://localhost:5173

# ======== JWT Configuration ========
# CRITICAL SECURITY: JWT secret key for token signing (REQUIRED)
# Minimum: 32 characters (256 bits) for HMAC-SHA256
# Recommended: 64+ characters for production (512+ bits entropy)
#
# LOCAL DEVELOPMENT:
#   - Default key provided: dev-secret-key-only-for-local-development-change-in-production
#   - Change before committing sensitive code
#
# PRODUCTION:
#   - MUST be set via environment variable JWT_SECRET_KEY
#   - MUST NOT be in code or .properties files
#   - Use openssl rand -base64 32 to generate (minimum)
#   - Use openssl rand -base64 64 to generate (recommended)
#   - Application will NOT start with weak or default key in prod
#
# Example for production:
#   export JWT_SECRET_KEY=$(openssl rand -base64 64)
#   java -jar app.jar
#
# Or in Docker:
#   docker run -e JWT_SECRET_KEY="$(openssl rand -base64 64)" myapp:latest
app.jwt.secret-key=${JWT_SECRET_KEY:dev-secret-key-only-for-local-development-change-in-production}
app.jwt.expiration-hours=${JWT_EXPIRATION_HOURS:24}

# ======== Springdoc OpenAPI (Swagger UI) Configuration ========
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.operations-sorter=method
springdoc.swagger-ui.tags-sorter=alpha
